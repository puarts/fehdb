# 「！」マーク誤判定問題

## 概要

スキル一覧画面（「習得可能スキル」ヘッダー付き）で、新スキルと既存スキルが同じ画面に並んでいる場合、VLMが「！」マークの有無を誤判定する。

## 発生状況

### 再現例（2026-03-01 双界総選挙ヘクトル＆セリカ）

フレーム画像は `.work/gemini-test/frames/` に保存（`--id gemini-test --keep-frames` で実行時）。

JP OCR frame_00004.png（`.work/gemini-test/frames/jp/frame_00004.png`、セリカのスキル一覧）:
- ✅ `双愛王家の剣`（新スキル、「！」あり）→ 正しく抽出
- ❌ `角逐`（既存スキル、「！」なし）→ 誤って新スキルとして抽出

EN OCR frame_00002.png（`.work/gemini-test/frames/en/frame_00002.png`、Hectorのスキル一覧）:
- ❌ `Patience`（既存スキル、「！」なし）→ 誤って新スキルとして抽出
- ❌ `A/D Briar F Save`（既存スキル、「！」なし）→ 誤って新スキルとして抽出
- ⚠️ `Ostian Backbone`（新スキル、「！」あり）→ 抽出漏れ（フレーム重複除去で別フレームに存在）

## 原因

1. **VLMが一覧全体を見て判断**: 1フレーム（スキル一覧画面）に新旧5〜8スキルが並んでいる状態でVLMに送信している。「！」マークはオレンジ/黄色の小さいアイコンで、スキル種別アイコン（丸型バッジ）と混同しやすい
2. **プロンプトの限界**: 「！マークがないスキルは無視」と指示しているが、VLMが小さなマークの有無を正確に区別できない場合がある
3. **影響**: 既存スキルが新スキルとして出力に混入する、または新スキルが抽出漏れする

## スキル一覧画面のレイアウト

```
┌─────────────────────────────┐
│  習得可能スキル              │
├─────────────────────────────┤
│ ！ ● 双愛王家の剣           │  ← 新スキル（「！」あり）
├─────────────────────────────┤
│    ● 角逐                   │  ← 既存スキル（「！」なし）
├─────────────────────────────┤
│ ！ ● 攻速無欠・鬼没         │  ← 新スキル（「！」あり）
├─────────────────────────────┤
│    ● Patience               │  ← 既存スキル（「！」なし）
└─────────────────────────────┘
  ↑     ↑
  「！」 スキル種別アイコン（丸型）
  マーク ※ VLMがこの2つを混同することがある
```

- 「！」マーク: オレンジ/黄色、行の最左端、小さい
- スキル種別アイコン: 丸型バッジ、「！」の右隣、比較的大きい

## 解決策の候補

### A. OpenCVで行をクロップして個別にLLM判定

スキル一覧画面をOpenCVで行ごとに分割し、各行を個別にLLMへ送信する。

**メリット**:
- LLMが1スキルに集中できるため「！」判定精度が向上
- 他の行の情報に惑わされない

**デメリット**:
- 行検出ロジックの実装が必要（水平線検出）
- APIコスト増（1画面あたり5〜8回のAPI呼び出し）
- 一覧画面 vs 詳細カードの自動判別が必要

### B. OpenCVで「！」マークを直接色検出

「！」マークは固定位置（行の左端）・固定色（オレンジ/黄色）なので、OpenCVの色検出で「！」の有無を判定する。LLMは「！」判定に不要になる。

```
1. 水平線検出 → 行境界を特定
2. 各行の左端領域をクロップ（「！」表示位置）
3. オレンジ/黄色ピクセルの有無で「！」判定
4. 「！」あり行のスキル名部分をOCR
```

**メリット**:
- LLM不要で高速・低コスト
- 色の閾値が適切なら誤判定がほぼゼロ

**デメリット**:
- 動画の圧縮ノイズ・解像度・明るさの変動に弱い
- 行検出ロジックの実装が必要
- 色閾値のキャリブレーションが必要

### C. DB照合による後処理フィルタ

VLMの抽出結果を `feh-skills.sqlite3` と照合し、既知のスキル名を除外する。

```python
# 抽出後に既存スキルを除外
existing = {row[0] for row in db.execute("SELECT name FROM skills")}
new_skills = [s for s in extracted if s.skill_name not in existing]
```

**メリット**:
- 実装が最も簡単（DB問い合わせのみ）
- 既存スキルの誤抽出を確実に排除

**デメリット**:
- 同名の新スキル（錬成版など名前が同一のケース）を誤って除外するリスク
- DBが最新でないと機能しない
- 抽出漏れ（新スキルをVLMが見逃す問題）は解決しない

### D. 現状維持（手動修正）

誤検出の頻度が低い場合、手動でドライラン結果を確認・修正する。

**メリット**:
- 追加実装不要
- ドライランで事前確認可能

**デメリット**:
- 毎回の確認コスト
- 見落としリスク

## 現時点の対応状況

- `all_frames` 修正済み: EN OCRでフレームグループの全フレームをVLMに送信するよう変更（フレーム重複除去による抽出漏れを軽減）
- 「！」誤判定自体は未解決（VLM精度依存のまま）

## スキル行クロップ検証（2026-03-01）

### 検証結果

`verify_crop_rows.py` で金色ボーダー検出によるスキル行クロップが可能であることを確認した。

- PIL + numpy のみで実装（OpenCV不要）
- `frames.py` の `_count_horizontal_edges()` を拡張し、エッジグループの最小輝度（< 100）とスパン（>= 8px）で金色ボーダーをノイズと分離
- ボーダー検出は狭い領域（`DETECT_PANEL_CROP = (0.45, 0.05, 0.98, 0.95)`）で行い、クロップ出力はスキル名・アイコンを含む広い領域（`OUTPUT_PANEL_CROP = (0.03, 0.05, 0.98, 0.95)`）から切り出す
- スキル画面判定: 金色ボーダー3本以上 AND 明るいピクセル比率30%以上

| | JP | EN |
|---|---|---|
| 処理フレーム | 7/22 | 10/24 |
| クロップ行数 | 16行 | 21行 |
| スキップ（非スキル画面） | 15 | 14 |

各クロップが1つのスキルカードを正確に含むことを目視確認済み。非スキル画面（英雄紹介、召喚バナー、ストーリー等）は正しくスキップされる。

### 解決方針（段階的アプローチ）

行クロップの成功を前提に、以下の3ステップで「！」マーク判定精度を段階的に改善する。各ステップ単体で効果を検証し、十分な精度が得られた時点で完了とする。

#### Step 1: クロップしたスキル行を個別にLLMに送信

画面全体ではなくクロップした1スキルずつをLLMに送信する。LLMが1つのスキルに集中して判断できるため、他の行の「！」マークとの混同がなくなり、これだけでも精度向上が期待できる。

```
[スキル行クロップ画像] → LLM → 「！」の有無 + スキル情報
```

#### Step 2: 「！」マークの参照画像をヒントとして添付

「！」マークの実例画像を参照画像（few-shot example）としてクロップ画像と共にLLMに渡す。LLMが「！」の見た目を正確に把握した上で判定できる。

```
[「！」マーク参照画像] + [スキル行クロップ画像] → LLM → 「！」の有無 + スキル情報
```

#### Step 3: 「！」マーク位置を追加クロップしてLLMに渡す

スキル行の左端（「！」マークがあるべき位置）をさらにクロップし、拡大画像としてLLMに渡す。微小なマークの有無を判断しやすくなる。

```
[「！」マーク参照画像] + [スキル行クロップ画像] + [左端拡大クロップ] → LLM → 「！」の有無 + スキル情報
```

## 関連ファイル

- `ocr.py`: `EN_USER_PROMPT_NEW_ONLY` — 「！」マーク判定指示を含むプロンプト
- `ocr.py`: `JP_USER_PROMPT_NEW_ONLY` — 同上（日本語版）
- `frames.py`: スキル画面検出・重複除去ロジック
- `verify_crop_rows.py`: スキル行クロップ検証スクリプト
